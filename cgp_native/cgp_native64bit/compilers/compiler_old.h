//=======================================================================================
//This file was generated by CGP generator (http://www.fit.vutbr.cz/~vasicek/cgp) 
//=======================================================================================

#if !(defined __LP64__ || defined __LLP64__) || defined _WIN32 && !defined _WIN64
 #error "32-bit architecture is not supported"
#else
 // we are compiling for a 64-bit system
#endif

unsigned char* consts;
void cgp_init_consts()
{
    #define B(val)  *(pconst++)=(val)
    unsigned char* pconst;
    pconst = consts = malloc_aligned(10);
    ///Initialize constants
    B(0x34); B(0x12); B(0x00); B(0x00); B(0x56); B(0x13); B(0x00); B(0x00); B(0xe2); B(0x1f); 
}

#define MAXCODESIZE 24
typedef void evalfunc(void);
unsigned char* code[MAX_POPSIZE];
void cgp_compile(unsigned char* pcode, chromosome p_chrom, int* isused)
{
    #define C(val)  *(pcode++)=(val)
    #define CI(val) {*((uint32_t *)(pcode))= (uint32_t)((__PTRDIFF_TYPE__)val); pcode += sizeof(uint32_t);}
    #define CL(val) {*((uint64_t *)(pcode))= (uint64_t)((__PTRDIFF_TYPE__)val); pcode += sizeof(uint64_t);}

    int pnodeout = 0;
    int in1,in2,fce;
    int out = params.inputs - 1;

    /// Save modified registers
    /// %rbx, %rax
    C(0x53);                                          //push   %rbx
    /// Load pointer to node outputs array into ebx
    C(0x48);C(0xbb);CL(nodeoutput);
    /// Native code generation
    for (int i=0; i < params.cols; i++)
        for (int j=0; j < params.rows; j++) 
        { 
            in1 = *p_chrom++; in2 = *p_chrom++; fce = *p_chrom++; out++;
            #ifdef DONOTEVALUATEUNUSEDNODES
            if (!isused[out]) continue;
            #endif
            switch (fce)
            {
              case 0:
                  ///nodeoutput[out] = nodeoutput[in1];
                  C(0x48);C(0x8b);C(0x83);CI(8*in1);                //mov    in1(%rbx),%rax
                  C(0x48);C(0x89);C(0x83);CI(8*out);                //mov    %rax,out(%rbx)
                  //code size: 14, stack requirements: 0
                  //registers: %rbx, %rax
                  break;
              case 1:
                  ///nodeoutput[out] = ~nodeoutput[in1];
                  C(0x48);C(0x8b);C(0x83);CI(8*in1);                //mov    in1(%rbx),%rax
                  C(0x48);C(0xf7);C(0xd0);                          //not    %rax
                  C(0x48);C(0x89);C(0x83);CI(8*out);                //mov    %rax,out(%rbx)
                  //code size: 17, stack requirements: 0
                  //registers: %rbx, %rax
                  break;
              case 2:
                  ///nodeoutput[out] = nodeoutput[in1] & nodeoutput[in2];
                  C(0x48);C(0x8b);C(0x83);CI(8*in1);                //mov    in1(%rbx),%rax
                  C(0x48);C(0x23);C(0x83);CI(8*in2);                //and    in2(%rbx),%rax
                  C(0x48);C(0x89);C(0x83);CI(8*out);                //mov    %rax,out(%rbx)
                  //code size: 21, stack requirements: 0
                  //registers: %rbx, %rax
                  break;
              case 3:
                  ///nodeoutput[out] = nodeoutput[in1] | nodeoutput[in2];
                  C(0x48);C(0x8b);C(0x83);CI(8*in1);                //mov    in1(%rbx),%rax
                  C(0x48);C(0x0b);C(0x83);CI(8*in2);                //or     in2(%rbx),%rax
                  C(0x48);C(0x89);C(0x83);CI(8*out);                //mov    %rax,out(%rbx)
                  //code size: 21, stack requirements: 0
                  //registers: %rbx, %rax
                  break;
              case 4:
                  ///nodeoutput[out] = nodeoutput[in1] ^ nodeoutput[in2];
                  C(0x48);C(0x8b);C(0x83);CI(8*in1);                //mov    in1(%rbx),%rax
                  C(0x48);C(0x33);C(0x83);CI(8*in2);                //xor    in2(%rbx),%rax
                  C(0x48);C(0x89);C(0x83);CI(8*out);                //mov    %rax,out(%rbx)
                  //code size: 21, stack requirements: 0
                  //registers: %rbx, %rax
                  break;
              case 5:
                  ///nodeoutput[out] = ~(nodeoutput[in1] & nodeoutput[in2]);
                  C(0x48);C(0x8b);C(0x83);CI(8*in1);                //mov    in1(%rbx),%rax
                  C(0x48);C(0x23);C(0x83);CI(8*in2);                //and    in2(%rbx),%rax
                  C(0x48);C(0xf7);C(0xd0);                          //not    %rax
                  C(0x48);C(0x89);C(0x83);CI(8*out);                //mov    %rax,out(%rbx)
                  //code size: 24, stack requirements: 0
                  //registers: %rbx, %rax
                  break;
              case 6:
                  ///nodeoutput[out] = ~(nodeoutput[in1] | nodeoutput[in2]);
                  C(0x48);C(0x8b);C(0x83);CI(8*in1);                //mov    in1(%rbx),%rax
                  C(0x48);C(0x0b);C(0x83);CI(8*in2);                //or     in2(%rbx),%rax
                  C(0x48);C(0xf7);C(0xd0);                          //not    %rax
                  C(0x48);C(0x89);C(0x83);CI(8*out);                //mov    %rax,out(%rbx)
                  //code size: 24, stack requirements: 0
                  //registers: %rbx, %rax
                  break;
              case 7:
                  ///nodeoutput[out] = ~(nodeoutput[in1] ^ nodeoutput[in2]);
                  C(0x48);C(0x8b);C(0x83);CI(8*in1);                //mov    in1(%rbx),%rax
                  C(0x48);C(0x33);C(0x83);CI(8*in2);                //xor    in2(%rbx),%rax
                  C(0x48);C(0xf7);C(0xd0);                          //not    %rax
                  C(0x48);C(0x89);C(0x83);CI(8*out);                //mov    %rax,out(%rbx)
                  //code size: 24, stack requirements: 0
                  //registers: %rbx, %rax
                  break;
              default:
                  abort();
              }
        } 
    /// Restore modified registers
    C(0x5b);                                          //pop    %rbx
    /// Return
    C(0xc3);
}
